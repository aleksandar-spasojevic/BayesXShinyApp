#' execute a command on bayesX CLI
#'
#' @param prg_path program (in 'bayesX' language) to execute on bayesX
#' @return an object of type 'bayesXResult' which contains the output generated
#' by bayesX CLI
#'
#' @export
bayesX <- function(prg_path, ...){
  if ( !file.exists(prg_path) ) stop("program path not present")
  bayesXResult <- suppressWarnings(BayesXsrc::run.bayesx(prg_path, verbose = FALSE)$log)
  class(bayesXResult) <- c("bayesXResult", class(bayesXResult))
  attr(bayesXResult, "prg") <- readLines(prg_path)
  
  # create new data environment, where data is stored
  # TODO: if data_ fails, do not store data environment and proceed further
  data_env <- new.env()
  assign("Data", data_(bayesXResult), envir = data_env)
  # NOTE: I assume only numeric predictors since I am using 'range'
  eval(parse(text = "Ranges <- lapply(Data, function(var) {r <- range(var);c(floor(r[1]), ceiling(r[2]))})"), envir = data_env)
  eval(parse(text = "Sequences <- lapply(Data, function(var) seq(floor(var[1]), ceiling(var[2]), length.out = 101))"), 
       envir = data_env)
  attr(bayesXResult, "data_env") <- data_env
  return(bayesXResult)
}


#' access objects from data environment
#' @export
get_ <- function(obj, what, ...) UseMethod("get_")

#' @export
get_.default <- function(obj, what, ...){
  envir <- attr(obj, "data_env")
  if( is.null(envir) )
    stop("object has no data environment")
  get(what, envir = envir)
}


#' extract information of bayesXResult
#'
#' @param pattern see in \code{\link{grep}}
#' @param ... further arguments passed to \code{\link{grep}}
#' @return a \code{list} with successfull match (\code{character}) and where
#' \code{numeric} match in bayesXResult happend
#'
#' @examples \dontrun{extract(res, "Acceptance rate")
#' library(BayesXShinyApp)
#' res <- bayesX("./inst/template.prg")
#' extract(res, "Acceptance rate")
#' extract(res, "Variance")
#' extract(res, "Minimum")
#' extract(res, "Maximum")
#' ex <- extract(res, "mean")
#' rbind(res[ex$where-1], ex$match, res[ex$where+1])}
#'
#' @export
extract <- function(bayesXResult, pattern, ...) UseMethod("extract")

#' @export
extract.bayesXResult <- function(bayesXResult, pattern, ...){
  where_match <- grep(pattern, bayesXResult, ...)
  list(match = bayesXResult[where_match], where = where_match)
}


#' get output path generated by bayesX CLI
#'
#' @param bayesXResult is the object generated by \code{\link{bayesX}}
#' @return \code{character} vector which can be interpreted as path
#'
#' @examples \dontrun{output_path(res)
#' list.files(output_path(res),full.names = TRUE)}
#'
#' @export
output_path <- function(bayesXResult, ...) UseMethod("output_path")

#' @export
output_path.bayesXResult <- function(bayesXResult, ...){
  # some of the output files end with *.res, extract one of them and take the
  # directory of it, which is in sense the 'output'
  path <- extract(bayesXResult, "*.res$", ...)$match[1] # take the first match
  # remove leading|trailing whitespaces or if string 'NOTE ...' present and 
  # return output directory path
  path_clean <- gsub("NOTE: created directory |^\\s+|\\s+$", "", path)
  dir_path <- dirname(path_clean)
  if( dir.exists(dir_path) )
    return(dir_path)
  else
    stop(paste("output path can not be parsed:", path))
}


#' extracts key value pairs from 'output' directory generated by bayesX CLI
#' @note we do not export this method, is an internal method
get_key_values <- function(line, data_env, ...){
  key_values <- unlist(strsplit(line, ","))
  meta <- list()
  for (pair in key_values) {
    splitted <- unlist(strsplit(pair, "="))
    key <- splitted[1]; value <- splitted[2]
    meta[key] <- value
  }
  # if line contains 'term' we declare it as an effect
  is_effect <- grepl("term", line)
  if ( is_effect )
    class(meta) <- c("effect", class(meta))

  return(meta)
}


#' 'bayesXOutput' constructor for 'output/' files generated by bayesX CLI
#'
#' class which contains information about 'output/' files generated by
#' \code{\link{bayesX}}
#'
#' @param bayesXResult is the object generated by \code{\link{bayesX}}
#'
#' @export
bayesXOutput <- function(bayesXResult, ...) UseMethod("bayesXOutput")

#' @export
bayesXOutput.bayesXResult <- function(bayesXResult, ...){
  r_file <- readLines(list.files(output_path(bayesXResult), "*.r$",
                                 full.names = TRUE))
  # extract information of .r file in output per line
  output_meta <- lapply(r_file, get_key_values, attr(bayesXResult, "data_env"))
  class(output_meta) <- c("bayesXOutput", class(output_meta))
  attr(output_meta, "data_env") <- attr(bayesXResult, "data_env")
  return(output_meta)
}


#' @note since user only passes the output directory, we do not know where
#' data sample is stored
#' 
#' @rdname bayesXOutput
#' 
#' @export
bayesXOutput.character <- function(path, ...){
  r_file <- readLines(list.files(path, "*.r$", full.names = TRUE))
  # extract information of .r file in output per line
  output_meta <- lapply(r_file, get_key_values, NULL)
  class(output_meta) <- c("bayesXOutput", class(output_meta))
  attr(output_meta, "data_env") <- NULL
  return(output_meta)
}


#' subscript operator for 'bayesXOutput' objects
#'
#' extracts meta information out of 'output/*.r' file generated by
#' \code{\link{bayesX}}
#'
#' @param bayesXOutput is the object generated by \code{\link{bayesXOutput}}
#'
#' @export
"[.bayesXOutput" <- function(bayesXOutput, i, drop = TRUE, ...){
  sapply(bayesXOutput, "[", i, drop = drop, ...)
}


#' @export
linear <- function(effect, ...) UseMethod("linear")

#' @export
linear.effect <- function(effect, ...){
  return( grepl("^linear", effect[["filetype"]]) )
}


#' @export
has_constant <- function(effect, ...) UseMethod("has_constant")

#' @export
has_constant.effect <- function(effect, ...){
  return( grepl("const", effect[["term"]]) )
}


#' @export
nonlinear <- function(effect, ...) UseMethod("nonlinear")

#' @export
nonlinear.effect <- function(effect, ...){
  return( grepl("^nonlinear", effect[["filetype"]]) )
}


#' @export
variables <- function(effect, ...) UseMethod("variables")

#' @export
variables.effect <- function(effect, ...){
  # remove 'const' if present
  variables <- gsub("const", "", effect[["term"]])
  # remove leading|trailing whitespaces and possible smooth 'sx(...)' key
  # also clean ',' if multiple covariates in smooth function
  variables_clean <- unlist(strsplit(gsub("^\\s+|s\\(|sx\\(|\\)|\\s+$", "", variables), ","))
  return( unlist(strsplit(variables_clean, " ")) )
}

#' @export
variables.bayesXOutput <- function(bayesXOutput, ...){
  variables <- lapply(bayesXOutput, function(elem){
    tryCatch(variables(elem), 
             warning = function(w) NULL, 
             error = function(e) NULL)
  }, ...)
  return( unique(unlist(variables)) )
}


#' @export
data_.default <- function(obj, ...){
  return( get_(obj, "Data")[variables(obj)] )
}


#' @export
ranges <- function(obj, ...) UseMethod("ranges")

#' @export
ranges.default <- function(obj, ...){
  return( get_(obj, "Ranges")[variables(obj)] )
}


#' @export
sequences <- function(obj, ...) UseMethod("sequences")

#' @export
sequences.default <- function(obj, ...){
  return( get_(obj, "Sequences")[variables(obj)] )
}


#' predict an effect
#' 
#' @export
predict.effect <- function(effect, X, ...){
  len <- length(X[[1]])
  # extract only variables which are member of effect
  X <- X[variables(effect)] # if 'X' a list not slow
  
  if ( linear(effect) ) {
    if ( has_constant(effect) )
      X <- append(X, list(const = rep.int(1, len)), after = 0) # append '1' would work, but dimension in parameters not of same dimension ('sweep' a possible solution)
    design_matrix <- do.call(cbind, X)
    
  } else if ( nonlinear(effect) ) {
    basis <- source(effect[["pathbasis"]], local = TRUE)$value
    design_matrix <- basis(X)
    
  } else {
    stop( sprintf("%s: type of effect not supported", effect[["filetype"]]) )
  }
  
  params <- t(read.table(effect[["pathsamples"]], header = TRUE)[,-1])
  predicts <- design_matrix %*% params
  return( structure(list(predicts), names = effect[["equationtype"]]) )
}


#' recieve distributional parameters (e.g \strong{\eqn{\eta}}'s)
#' 
#' returns sample of distributional parameters (e.g \strong{\eqn{\eta}})
#' 
#' @export
parameters <- function(bayesXOutput, ...) UseMethod("parameters")

#' @export
parameters.bayesXOutput <- function(bayesXOutput, 
                                    # if 'X' not given, we take sequence of each variable in data,
                                    # make grid and predict on this grid
                                    X = expand.grid(sequences(bayesXOutput)[variables(bayesXOutput)]),
                                    ...){
  # tryCatch since some elements of bayesXOutput are not of type 'effect'. If
  # one 'elem' is not of type 'effect' we will return 'NULL' otherwise 
  # 'predict.effect' function is called
  force(X)
  effects_predicted <- unlist(lapply(bayesXOutput, function(elem, ...){
    tryCatch(predict(elem, X = X, ...), 
             warning = function(w) NULL,
             error = function(e) NULL)
  }, ...), recursive = FALSE, use.names = TRUE)
  
  etas <- tapply(effects_predicted, 
                 INDEX = names(effects_predicted), 
                 FUN = function(...) {
                   eta <- do.call("+", ...)
                   class(eta) <- c("parameter", class(eta))
                   return(eta)
                 })
  
  return(structure(etas, 
                   class = c("parameters", class(etas)),
                   X = structure(as.list(X), out.attrs = NULL)))
}

#' subscript operator for 'parameters' objects
#' 
#' @note one can use \code{\link{all.equal}} to extract rows. Row's represent 
#' the underlying grid of covariates. Covariates cannot be compared with 
#' \code{==} operator, since they are \code{numeric}. Therefore one prefers 
#' \code{\link{all.equal}} for 'near equality'. Using \code{\link{all.equal}} 
#' will either result in a \code{character} \code{TRUE} or message, 
#' therefore we have to check if it's a \code{character}, if so, we extract indexes 
#' where \code{TRUE} stays and use those for indexing. Drawback of this is slowness!
#' @export
"[.parameters" <- function(parameters, ...){
  match <- with(attr(parameters, "X"), ...)
  # subset by row
  sel_params <- lapply(parameters, "[", match, , drop = FALSE)
  
  # set again classes
  for( index in 1:length(sel_params) )
    class(sel_params[[index]]) <- c("parameter", class(sel_params[[index]]))
  class(sel_params) <- c("parameters", class(sel_params))
  attr(sel_params, "X") <- lapply(attr(parameters, "X"), "[", match, drop = FALSE)
  
  return(sel_params)
}


#' @export
quantile.parameters <- function(parameters, ...){
  lapply(parameters, quantile, ...)
}


#' @export
quantile.parameter <- function(parameter, ...){
  # over 'columns'
  apply(parameter, FUN = quantile, ...)
}


#' @export
mean.parameters <- function(parameters, ...){
  lapply(parameters, mean, ...)
}


#' @export
mean.parameter <- function(parameter, ...){
  apply(parameter, FUN = mean, ...)
}


#' @export
var <- function(parameters, ...) UseMethod("var")

#' @export
var.parameters <- function(parameters, ...){
  lapply(parameters, var, ...)
}

#' @export
var.parameter <- function(parameter, ...){
  apply(parameter, FUN = stats::var, ...)
}


#' @export
sd <- function(parameters, ...) UseMethod("sd")

#' @export
sd.parameters <- function(parameters, ...){
  lapply(parameters, sd, ...)
}

#' @export
sd.parameter <- function(parameter, ...){
  apply(parameter, FUN = stats::sd, ...)
}


#' get data used in bayesX supplied program
#'
#' @param bayesXResult is the object generated by \code{\link{bayesX}}
#'
#' @export
data_ <- function(bayesXResult, ...) UseMethod("data_")

#' @export
data_.bayesXResult <- function(bayesXResult, header = TRUE, ...){
  program <- attr(bayesXResult, "prg")
  # search 'infile using ' in supplied program (prg). If match available, then
  # extract data path
  key <- "infile using "
  key_match <- grep(key, program, value = TRUE)[1]
  # TODO: filepath can contain 'whitespaces', this is not covered in this pattern
  # and will fail if such path occurs
  data_path <- gsub("^(.*)\\s(.*)(/[^/]+$)", "\\2\\3", key_match)
  if ( !file.exists(data_path) )
    stop(sprintf("%s: can not be parsed", key_match))
  
  return(utils::read.table(data_path, header = header, ...))
}

